filter {
    if "process_syslog" in [tags] and "process_live" in [tags] {
        mutate {
            rename => [ "program", "syslog_program" ]
            rename => [ "logsource", "syslog_hostname" ]
            rename => [ "pid", "syslog_pid" ]
            rename => [ "timestamp", "syslog_timestamp" ]
            add_tag => [ "got_syslog_timestamp", "got_syslog_hostname", "got_syslog_program" ]
            ### DEBUG
            ###add_field => { "orig_message" => "%{message}" }
        }
    }

    if "process_syslog" in [tags] {
        if "syslog" in [tags] {
            mutate {
                add_field => { "path" => "syslog from %{host}" }
            }
        } else if "relp" in [tags] {
            mutate {
                add_field => { "path" => "relp from %{host}" }
            }
        } else if "filebeat" in [tags] {
            mutate {
                add_field => { "path" => "filebeat from %{host}: %{source}" }
            }
        } else if !("file" in [tags]) {
            mutate {
                add_field => { "path" => "unknown syslog source" }
            }
        }
    }

    # Check if syslog message has PRI.     If so then :
    #  strip the syslog PRI part and create facility and severity fields.
    #  the extracted PRI is available in the %{syslog_pri} field.
    #
    #  You get %{syslog_facility_code} and %{syslog_severity_code} fields.
    #  You also get %{syslog_facility} and %{syslog_severity} fields if the
    #  use_labels option is set True (the default) on syslog_pri filter.
    if "process_syslog" in [tags] and "process_archive" in [tags] and [message] =~ /^<\d+>/ {
        mutate { add_tag => [ "has_pri" ] }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "has_pri" in [tags] {
        grok {
            match => [ "message", "<%{POSINT:syslog_pri}>%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_pri" ]
            tag_on_failure => [ "_gpfail", "fail_sl01" ]
        }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "got_syslog_pri" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "process_archive" in [tags] and "got_syslog_pri" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_pri" in [tags] {
        mutate {
            # XXX must not be combined with replacement which uses same field
            remove_field => [ "message_remainder" ]
        }
        syslog_pri {
            use_labels => false
            add_tag => [ "rename_priority_fields" ]
        }
    }

    if "rename_priority_fields" in [tags] {
        mutate {
            rename => [ "syslog_facility_code", "facility" ]
            rename => [ "syslog_severity_code", "severity" ]
            remove_tag => [ "rename_priority_fields", "got_syslog_pri" ]
            remove_field => [ "syslog_pri" ]
        }
    }

    # detect and handle files from Kiwi syslog server
    if "process_syslog" in [tags] and "process_archive" in [tags] {
        grok {
            match => [ "message", "%{TIMESTAMP_ISO8601:kiwi_timestamp}%{SPACE}%{WORD:kiwi_facility}.%{WORD:kiwi_severity}%{SPACE}%{IPORHOST:kiwi_host}%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_kiwi_syslog" ]
            tag_on_failure => [ "_gpfail", "fail_sl01a" ]
        }
    }

    if "got_kiwi_syslog" in [tags] {
        mutate {
            lowercase => [ "kiwi_facility", "kiwi_severity" ]
        }

        # convert the text priority fields to integers
        translate {
            dictionary_path => "/usr/local/for572logstash/lib/syslog_facility_lookup.yaml"
            field => "[kiwi_facility]"
            destination => "[facility]"
        }
        translate {
            dictionary_path => "/usr/local/for572logstash/lib/syslog_severity_lookup.yaml"
            field => "[kiwi_severity]"
            destination => "[severity]"
        }
        # remove the text facility and severity fields, waterfall the rest of the message up
        if [facility] and [severity] {
            mutate {
                remove_field => [ "kiwi_facility", "kiwi_severity" ]
                replace => [ "message", "%{message_remainder}" ]
            }
        }

        if [message_remainder] and [message_remainder] != "" {
            mutate {
                # XXX must not be combined with replacement which uses same field
                remove_field => [ "message_remainder" ]
            }
        }
    }

    # strip the syslog timestamp and force event timestamp to be the same.
    # the original string is saved in field %{syslog_timestamp}.
    # the original logstash input timestamp is saved in field %{received_at}.
    # NOTE: I'm not sure I like handling the cisco_message_counter here rather than later with the rest of the Cisco stuff
    #       that said, it appears at the beginning of the message in this case, so I think we're stuck. This grok doesn't require
    #       the field, so hopefully it'll be a graceful and uneventful optional match.
    #       Would be interested in moving this to later in the pipeline if it all possible, though.
    if "process_syslog" in [tags] and "process_archive" in [tags] {
        grok {
            patterns_dir => "/usr/local/for572logstash/grok-patterns"
            match => [ "message", "^(?:%{POSINT:cisco_message_counter}: \*)?%{FULLSYSLOGTIMESTAMP:syslog_timestamp}%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_timestamp" ]
            add_field => { "received_at" => "%{@timestamp}" }
            tag_on_failure => [ "_gpfail", "fail_sl02" ]
        }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "file" in [tags] {
        grok {
            match => [ "path", "\/%{YEAR:path_year}\/" ]
            add_tag => [ "got_path_year" ]
            tag_on_failure => [ "_gpfail", "fail_sl03" ]
        }
    }

    if "got_path_year" in [tags] {
        mutate {
            replace => [ "syslog_timestamp", "%{syslog_timestamp} %{path_year}" ]
            remove_field => "path_year"
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        mutate {
            # XXX must not be combined with replacement which uses same field
            remove_field => [ "message_remainder" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        date {
            # season to taste for your own syslog format(s)
            # RFC3339 via rsyslog is "2016-05-10T01:49:03.863938+00:00"
            match => [ "syslog_timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "ISO8601", "MMM dd HH:mm:ss yyyy", "MMM  d HH:mm:ss yyyy", "MMM dd yyyy HH:mm:ss", "MMM  d yyyy HH:mm:ss" ]
        }
    }

    if "process_syslog" in [tags] and [message] =~ /MSWinEventLog/ {
        mutate {add_tag => [ "got_eventlog_msg" ] }
    }

    # strip the host field from the syslog line.
    # the extracted host field becomes the logstash %{host} metadata
    # and is also available in the field %{syslog_hostname}.
    # the original logstash host is saved in field %{logstash_source}.
    if "process_syslog" in [tags] and !("got_eventlog_msg" in [tags]) {
        grok {
            patterns_dir => "/usr/local/for572logstash/grok-patterns"
            match => [ "message", "^%{SYSLOGHOST:syslog_hostname}%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_hostname" ]
            add_field => { "logstash_source" => "%{host}" }
            tag_on_failure => [ "_gpfail", "fail_sl04" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "host", "%{syslog_hostname}" ]
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] {
        mutate {
            # message_remainder no longer needed.
            remove_field => [ "message_remainder" ]
        }
    }

    # strip the program and optional pid field from the syslog line.
    # available in the field %{syslog_program} and %{syslog_pid}.
    # note that we do NOT do this for live syslog, as the value has already been provided by the syslog input handler
    if "process_syslog" in [tags] and !("got_eventlog_msg" in [tags]) {
        grok {
            patterns_dir => "/usr/local/for572logstash/grok-patterns"
            match => [ "message", "%{PROG:syslog_program}(?:\[%{POSINT:syslog_pid}\])?:%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_program" ] 
            tag_on_failure => [ "_gpfail", "fail_sl05" ]
        }
    }

    if "got_syslog_program" in [tags] {
        mutate {
            lowercase => [ "syslog_program" ]
        }
    }
    if "got_syslog_hostname" in [tags] {
        mutate {
            lowercase => [ "syslog_hostname" ]
        }
    }

    # handle snare records
    if "process_syslog" in [tags] and "got_eventlog_msg" in [tags] {
        grok {
            match => [ "message", "%{SYSLOGHOST:syslog_hostname}%{SPACE}MSWinEventLog#011(%{INT:evt_crit:int})?#011(%{DATA:evt_logsource})?#011(%{INT})?#011(%{DATA})?#011(%{INT:evt_id:int})?#011(%{DATA:evt_sourcename})?#011(%{DATA:evt_username})?#011(%{DATA:evt_sidtype})?#011(%{DATA:evt_logtype})?#011(%{DATA:evt_hostname})?#011(%{DATA})?#011(%{DATA:evt_data})?#011(%{DATA:evt_fulldata})?#011" ]
            add_tag => [ "parsed_snare_msg" ]
            add_field => { "logstash_source" => "%{host}" }
            tag_on_failure => [ "_gpfail", "fail_sl06" ]
        }
    }
    if [evt_fulldata] {
        mutate {
        replace => [ "message", "%{evt_fulldata}" ]
        remove_field => [ "evt_fulldata" ]
        }
    }
    if "process_syslog" in [tags] and "parsed_snare_msg" in [tags] {
        mutate {
            replace => [ "host", "%{syslog_hostname}" ]
            add_tag => [ "parse_done" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_program" in [tags] and [message_remainder] and [message_remainder] != "" and !( "parse_done" in [tags]) {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "got_syslog_program" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_program" in [tags] and !( "parse_done" in [tags]) {
        mutate {
            # message_remainder no longer needed.
            remove_field => [ "message_remainder" ]
        }
    }
}
